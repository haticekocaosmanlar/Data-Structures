# PALINDROME
# --------------------------------------------------------------------------------------------------
# Reverse strign solution
def is_palindrome(s):
  # Keep only alphanumeric characters and convert to lowercase
  cleaned = ''.join(char.lower() for char in s if char.isalnum())
  # Check if the cleaned string is a palindrome
  return cleaned == cleaned[::-1]

# Time Complexity: O(n)
# Let's break it down:
# Cleaning the string:
# Loop through each character in s: O(n)
# char.lower() and char.isalnum() are both O(1)
# Building a new string with ''.join(...): also O(n)
# Reversing and comparing:
# cleaned[::-1] creates a reversed copy â†’ O(n)
# Comparing two strings of length n: O(n)
# So total time: O(n) + O(n) + O(n) = O(n)

# Space Complexity: O(n)
# cleaned holds a new string up to length n
# cleaned[::-1] creates another copy of that string
# So total space:O(n)

# ---
# Two pointers solution 
def is_palindrome(s):
  i, j = 0, len(s) - 1

  while i < j:
      # Move left pointer until it points to an alphanumeric character
      while i < j and not s[i].isalnum():
          i += 1
      # Move right pointer until it points to an alphanumeric character
      while i < j and not s[j].isalnum():
          j -= 1

      # Compare the characters in lowercase
      if s[i].lower() != s[j].lower():
          return False

      # Move both pointers inward
      i += 1
      j -= 1
  return True

# Time Complexity: O(n)
# n is the length of the input string.
# Each character is visited at most once by either the left or right pointer.
# Even the inner while loops (that skip non-alphanumeric characters) only advance the pointers forward, never backward.
# So in total: linear time, O(n).

# Space Complexity: O(1)
# No additional data structures or copies of the string are created.
# Only a few integer variables (left, right) and temporary chars are used.
# So: constant space, O(1).


# 3SUM
# --------------------------------------------------------------------------------------------------
def three_sum(nums):
  nums.sort()
  result = []

  for pivot in range(len(nums) - 2):
    if nums[pivot] > 0:
      break
    
    # TODO: Skip duplicate pivots to avoid repeated triplets
    if pivot > 0 and nums[pivot] == nums[pivot - 1]:
        continue
    
    low, high = pivot + 1, len(nums) - 1
    while low < high:
      total = nums[pivot] + nums[low] + nums[high]
      if total < 0:
        low += 1
      elif total > 0:
        high -= 1
      else:
        # Found a triplet
        result.append([nums[pivot], nums[low], nums[high]])
        low += 1
        high -= 1
        # Skip duplicates for low and high
        while low < high and nums[low] == nums[low - 1]:
            low += 1
        while low < high and nums[high] == nums[high + 1]:
            high -= 1
  return result
